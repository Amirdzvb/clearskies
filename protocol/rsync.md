Rsync Extension
---------------

This is an optional protocol feature.  The official feature string is "rsync".
Feature negotiation is covered in the core protocol documentation.

The rsync extension increases wire efficiency by only transferring the parts of
files that have changed.

The behavior of the algorithm works similar to the "rdiff" command in unix,
where the "signature", "delta", and "patch" steps are done separately.

For file transfer, if a local file is already present and a delta is desired,
instead of issuing a "get" request, a "rsync.signature" request with a binary
payload can be sent:

```json
{
  "type": "rsync.signature",
  "path": "photos/img1.jpg"
}
```

The peer then responds with an "rsync.patch" message, with a binary payload of
the actual patch generated by the "delta" command:

```json
{
  "type": "rsync.patch",
  "path": "photos/img1.jpg",
  "mtime": 1379223577,
  "ctime": 1379223570,
  "mode": 0600,
  "sha1": "fd5b138f7e42bd28834fb7bf35aa531fbee15d7c"
}
```

The software then uses the patch and the old file to create a temporary file,
which is then used to overwrite the old file after verification of SHA1 sum, as
normal.


Rsync Listing Extension
-----------------------

This is an optional protocol feature.  The official feature string is
"rsync_tree".  Feature negotiation is covered in the core protocol
documentation.

The rsync algorithm can also used to exchange the directory tree.  The
"listing_hash" message is exchanged as usual.  Then the rest of the operations
operate on a textual representation of the keys.  Since JSON does not guarantee
the order of keys, a different representation is necessary.

The data will be written as text, newline separated, with the following fields
"path", "sha1", "mtime", "size", in that order.  Once all files have been
written, an extra newline represents the end of the listing.  Deleted files are
then listed, with "path" and "dtime" pairs, also newline separated.  A final
extra newline ends the deleted files list.  Anything after the deleted list
should be ignored for forwards compatibility.

If a path string contains any bytes outside the range of 0x00-0x7f, or contains
a newline (character 0x0a), it should be represented as UTF8.  This result is
then base64 encoded.  If the base64 encoded added newlines, they should be
removed).  ASCII paths are prefixed with "path:" and base64 paths are prefixed
with "base64:".

Implementors note: Is it necessary to normalize the strings (using NFD or NFC)
in order to be compatible with Windows?

Here is an example text representation of a file tree:

```
path:photos/img1.jpg
602aba74d093e7893e87c4ba4295021937087bc4
1379220393
2387629
base64:aW1hZ2VzL2VzcGHDsW9s4oCOLmpwZwo=
dbe2e1f6f295102b0b93d991ab4508979aa9433e
1379100421
6293123

path:photos/img3.jpg
1383030498
```

Then software first sends a "rsync_tree.signature".  The actual signature is a
binary payload.

```json
{
  "type": "rsync_tree.signature"
}
```

The peer responds with a "rsync_tree.patch".  Once again, the patch is a binary
payload.

```json
{
  "type": "rsync_tree.patch"
}
```

The software then applies the patch to its representation of the tree that was
sent originally, and decodes the ASCII representation, and then finally applies
the conflict resolution algorithm as normal.

Note that in two-way sync that both peers send the initial signature at the
same time.

